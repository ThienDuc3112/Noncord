// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id,
  created_at,
  updated_at,
  deleted_at,
  username,
  display_name,
  about_me,
  email,
  password,
  disabled,
  avatar_url,
  banner_url,
  flags
) VALUES ( 
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13
)
ON CONFLICT (id)
DO UPDATE SET 
  created_at = $2,
  updated_at = $3,
  deleted_at = $4,
  username = $5,
  display_name = $6,
  about_me = $7,
  email = $8,
  password = $9,
  disabled = $10,
  avatar_url = $11,
  banner_url = $12,
  flags = $13
RETURNING id, created_at, updated_at, deleted_at, username, display_name, about_me, email, password, disabled, avatar_url, banner_url, flags
`

type CreateUserParams struct {
	ID          uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   *time.Time
	Username    string
	DisplayName string
	AboutMe     string
	Email       string
	Password    pgtype.Text
	Disabled    bool
	AvatarUrl   string
	BannerUrl   string
	Flags       int16
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Username,
		arg.DisplayName,
		arg.AboutMe,
		arg.Email,
		arg.Password,
		arg.Disabled,
		arg.AvatarUrl,
		arg.BannerUrl,
		arg.Flags,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Username,
		&i.DisplayName,
		&i.AboutMe,
		&i.Email,
		&i.Password,
		&i.Disabled,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.Flags,
	)
	return i, err
}

const createUserSetting = `-- name: CreateUserSetting :one
INSERT INTO user_settings (
  user_id,
  language,
	dm_allow_option,
	dm_filter_option,
	friend_request_permission,
	collect_analytics_permission,
	theme,
	show_emote,
	notification_settings,
	afk_timeout
) VALUES (
  $1,
  $2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10
)
ON CONFLICT (id)
DO UPDATE SET 
  language = $2,
	dm_allow_option = $3,
	dm_filter_option = $4,
	friend_request_permission = $5,
	collect_analytics_permission = $6,
	theme = $7,
	show_emote = $8,
	notification_settings = $9,
	afk_timeout = $10
RETURNING user_id, language, dm_allow_option, dm_filter_option, friend_request_permission, collect_analytics_permission, theme, show_emote, notification_settings, afk_timeout
`

type CreateUserSettingParams struct {
	UserID                     uuid.UUID
	Language                   string
	DmAllowOption              int16
	DmFilterOption             int16
	FriendRequestPermission    int16
	CollectAnalyticsPermission bool
	Theme                      string
	ShowEmote                  bool
	NotificationSettings       int16
	AfkTimeout                 int64
}

func (q *Queries) CreateUserSetting(ctx context.Context, arg CreateUserSettingParams) (UserSetting, error) {
	row := q.db.QueryRow(ctx, createUserSetting,
		arg.UserID,
		arg.Language,
		arg.DmAllowOption,
		arg.DmFilterOption,
		arg.FriendRequestPermission,
		arg.CollectAnalyticsPermission,
		arg.Theme,
		arg.ShowEmote,
		arg.NotificationSettings,
		arg.AfkTimeout,
	)
	var i UserSetting
	err := row.Scan(
		&i.UserID,
		&i.Language,
		&i.DmAllowOption,
		&i.DmFilterOption,
		&i.FriendRequestPermission,
		&i.CollectAnalyticsPermission,
		&i.Theme,
		&i.ShowEmote,
		&i.NotificationSettings,
		&i.AfkTimeout,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, created_at, updated_at, deleted_at, username, display_name, about_me, email, password, disabled, avatar_url, banner_url, flags FROM users WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Username,
		&i.DisplayName,
		&i.AboutMe,
		&i.Email,
		&i.Password,
		&i.Disabled,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.Flags,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, created_at, updated_at, deleted_at, username, display_name, about_me, email, password, disabled, avatar_url, banner_url, flags FROM users WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) FindUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Username,
		&i.DisplayName,
		&i.AboutMe,
		&i.Email,
		&i.Password,
		&i.Disabled,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.Flags,
	)
	return i, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
SELECT id, created_at, updated_at, deleted_at, username, display_name, about_me, email, password, disabled, avatar_url, banner_url, flags FROM users WHERE username = $1 AND deleted_at IS NULL
`

func (q *Queries) FindUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Username,
		&i.DisplayName,
		&i.AboutMe,
		&i.Email,
		&i.Password,
		&i.Disabled,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.Flags,
	)
	return i, err
}

const findUserChannelNickname = `-- name: FindUserChannelNickname :one
SELECT mb.nickname, u.display_name, u.avatar_url FROM users u
LEFT JOIN channels c ON c.id = $1
LEFT JOIN memberships mb ON u.id = mb.user_id AND mb.server_id = c.server_id
WHERE u.id = $2
`

type FindUserChannelNicknameParams struct {
	ChannelID uuid.UUID
	UserID    uuid.UUID
}

type FindUserChannelNicknameRow struct {
	Nickname    pgtype.Text
	DisplayName string
	AvatarUrl   string
}

func (q *Queries) FindUserChannelNickname(ctx context.Context, arg FindUserChannelNicknameParams) (FindUserChannelNicknameRow, error) {
	row := q.db.QueryRow(ctx, findUserChannelNickname, arg.ChannelID, arg.UserID)
	var i FindUserChannelNicknameRow
	err := row.Scan(&i.Nickname, &i.DisplayName, &i.AvatarUrl)
	return i, err
}

const findUserServerNickname = `-- name: FindUserServerNickname :one
SELECT mb.nickname, u.display_name, u.avatar_url FROM users u
LEFT JOIN memberships mb ON u.id = mb.user_id AND mb.server_id = $1
WHERE u.id = $2
`

type FindUserServerNicknameParams struct {
	ServerID uuid.UUID
	ID       uuid.UUID
}

type FindUserServerNicknameRow struct {
	Nickname    pgtype.Text
	DisplayName string
	AvatarUrl   string
}

func (q *Queries) FindUserServerNickname(ctx context.Context, arg FindUserServerNicknameParams) (FindUserServerNicknameRow, error) {
	row := q.db.QueryRow(ctx, findUserServerNickname, arg.ServerID, arg.ID)
	var i FindUserServerNicknameRow
	err := row.Scan(&i.Nickname, &i.DisplayName, &i.AvatarUrl)
	return i, err
}
