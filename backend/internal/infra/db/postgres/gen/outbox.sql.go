// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const claimOutboxBatch = `-- name: ClaimOutboxBatch :many
WITH candidates AS (
  SELECT id
  FROM outbox
  WHERE status IN ('pending', 'inflight')
    AND (status = 'pending' OR claimed_at < now() - INTERVAL '2 minutes')
  ORDER BY occurred_at
  FOR UPDATE SKIP LOCKED
  LIMIT $1
)
UPDATE outbox AS o
SET status     = 'inflight',
    claimed_at = now(),
    attempts   = attempts + 1
FROM candidates c
WHERE o.id = c.id
RETURNING o.id, o.aggregate_name, o.aggregate_id, o.event_type, o.schema_version, o.occurred_at, o.payload, o.status, o.attempts, o.claimed_at, o.published_at
`

func (q *Queries) ClaimOutboxBatch(ctx context.Context, limit int32) ([]Outbox, error) {
	rows, err := q.db.Query(ctx, claimOutboxBatch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outbox
	for rows.Next() {
		var i Outbox
		if err := rows.Scan(
			&i.ID,
			&i.AggregateName,
			&i.AggregateID,
			&i.EventType,
			&i.SchemaVersion,
			&i.OccurredAt,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.ClaimedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEventToOutbox = `-- name: InsertEventToOutbox :one
INSERT INTO outbox( 
  id,
  aggregate_name,
  aggregate_id,
  event_type,
  schema_version,
  occurred_at,
  payload
) 
VALUES ($1, $2, $3, $4, $5, $6, $7) 
RETURNING id, aggregate_name, aggregate_id, event_type, schema_version, occurred_at, payload, status, attempts, claimed_at, published_at
`

type InsertEventToOutboxParams struct {
	ID            uuid.UUID
	AggregateName string
	AggregateID   uuid.UUID
	EventType     string
	SchemaVersion int32
	OccurredAt    time.Time
	Payload       []byte
}

func (q *Queries) InsertEventToOutbox(ctx context.Context, arg InsertEventToOutboxParams) (Outbox, error) {
	row := q.db.QueryRow(ctx, insertEventToOutbox,
		arg.ID,
		arg.AggregateName,
		arg.AggregateID,
		arg.EventType,
		arg.SchemaVersion,
		arg.OccurredAt,
		arg.Payload,
	)
	var i Outbox
	err := row.Scan(
		&i.ID,
		&i.AggregateName,
		&i.AggregateID,
		&i.EventType,
		&i.SchemaVersion,
		&i.OccurredAt,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.ClaimedAt,
		&i.PublishedAt,
	)
	return i, err
}

const markedOutboxDispatched = `-- name: MarkedOutboxDispatched :exec
UPDATE outbox SET status = 'dispatched', published_at = NOW() WHERE id = $1
`

func (q *Queries) MarkedOutboxDispatched(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markedOutboxDispatched, id)
	return err
}

const markedOutboxFailed = `-- name: MarkedOutboxFailed :exec
UPDATE outbox SET status = 'failed' WHERE id = $1
`

func (q *Queries) MarkedOutboxFailed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markedOutboxFailed, id)
	return err
}

const requeueOutbox = `-- name: RequeueOutbox :exec
UPDATE outbox SET status = 'pending', claimed_at = NULL WHERE id = $1
`

func (q *Queries) RequeueOutbox(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, requeueOutbox, id)
	return err
}
